#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <stdexcept>
#include <algorithm>

// Predefined opcodes (same as in vm.h)
const uint8_t OP_PUSH    = 0x01;
const uint8_t OP_PRINT   = 0x03;
const uint8_t OP_PRINTLN = 0x0A;

// Custom magic number
const uint32_t CUSTOM_MAGIC = 0x00DEFCAA;

// Helper function: trim whitespace from both ends of a string.
std::string trim(const std::string &s) {
    size_t start = s.find_first_not_of(" \t\r\n");
    if (start == std::string::npos) return "";
    size_t end = s.find_last_not_of(" \t\r\n");
    return s.substr(start, end - start + 1);
}

int main(int argc, char* argv[]) {
    if (argc != 4) {
        std::cerr << "Usage: covicc <input.covi> -o <output.cb>" << std::endl;
        return 1;
    }
    
    std::string inputFile = argv[1];
    std::string outputFile;
    if (std::string(argv[2]) != "-o") {
        std::cerr << "Usage: covicc <input.covi> -o <output.cb>" << std::endl;
        return 1;
    }
    outputFile = argv[3];
    
    std::ifstream fin(inputFile);
    if (!fin) {
        std::cerr << "Error: Cannot open input file " << inputFile << std::endl;
        return 1;
    }
    
    // Buffer to hold generated bytecode
    std::vector<uint8_t> bytecode;
    
    // Write magic number header in big-endian order.
    bytecode.push_back((CUSTOM_MAGIC >> 24) & 0xFF);
    bytecode.push_back((CUSTOM_MAGIC >> 16) & 0xFF);
    bytecode.push_back((CUSTOM_MAGIC >> 8) & 0xFF);
    bytecode.push_back(CUSTOM_MAGIC & 0xFF);
    
    std::string line;
    while (std::getline(fin, line)) {
        line = trim(line);
        if (line.empty() || line.substr(0,2) == "//") continue; // Skip comments/empty
        
        std::istringstream iss(line);
        std::string command;
        iss >> command;
        
        // Convert command to lowercase for simplicity.
        std::string cmdLower = command;
        std::transform(cmdLower.begin(), cmdLower.end(), cmdLower.begin(), ::tolower);
        
        // Support "print", "println" and "printnl" (treated same as println)
        if (cmdLower == "print" || cmdLower == "println" || cmdLower == "printnl") {
            std::string operand;
            std::getline(iss, operand);
            operand = trim(operand);
            if (!operand.empty() && operand.back() == ';')
                operand.pop_back();
            operand = trim(operand);
            if (operand.size() < 2 || operand.front() != '\"' || operand.back() != '\"') {
                std::cerr << "Error: Invalid operand (expected quoted string) in line: " << line << std::endl;
                return 1;
            }
            // Remove quotes.
            std::string text = operand.substr(1, operand.size() - 2);
            // For each character, emit: PUSH <char> then PRINT.
            for (char c : text) {
                bytecode.push_back(OP_PUSH);
                bytecode.push_back(static_cast<uint8_t>(c));
                bytecode.push_back(OP_PRINT);
            }
            // If command is "println" or "printnl", add the newline instruction.
            if (cmdLower == "println" || cmdLower == "printnl") {
                bytecode.push_back(OP_PRINTLN);
            }
        } else {
            std::cerr << "Error: Unsupported command in line: " << line << std::endl;
            return 1;
        }
    }
    fin.close();
    
    std::ofstream fout(outputFile, std::ios::binary);
    if (!fout) {
        std::cerr << "Error: Cannot open output file " << outputFile << std::endl;
        return 1;
    }
    fout.write(reinterpret_cast<const char*>(bytecode.data()), bytecode.size());
    fout.close();
    
    std::cout << "Compilation completed: " << outputFile << std::endl;
    return 0;
}
